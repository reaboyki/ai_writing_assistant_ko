/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIWritingAssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/ai-service.ts
var import_obsidian = require("obsidian");
var AIService = class {
  constructor() {
    this.providers = /* @__PURE__ */ new Map();
    this.cache = /* @__PURE__ */ new Map();
    this.requestQueue = /* @__PURE__ */ new Map();
    this.initializeProviders();
  }
  initializeProviders() {
    this.providers.set("openai", {
      id: "openai",
      name: "OpenAI",
      requiresApiKey: true,
      models: [
        {
          id: "o1",
          name: "o1 - \uACE0\uAE09 \uCD94\uB860",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 9e-3,
          // $15 input + $60 output / 2 -> 실제 $3 + $15
          isNew: true
        },
        {
          id: "o1-mini",
          name: "o1 Mini - \uAC00\uC131\uBE44",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 275e-5,
          // $1.1 input + $4.4 output / 2
          isNew: true
        },
        {
          id: "gpt-4o",
          name: "GPT-4o",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 0.0125
          // $5 input + $20 output / 2
        },
        {
          id: "gpt-4o-mini",
          name: "GPT-4o Mini",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 15e-4
          // $0.6 input + $2.4 output / 2
        },
        {
          id: "gpt-4-turbo",
          name: "GPT-4 Turbo",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 0.01
          // $10 input + $30 output / 2
        },
        {
          id: "gpt-3.5-turbo",
          name: "GPT-3.5 Turbo",
          maxTokens: 16385,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 2e-3
        }
      ]
    });
    this.providers.set("claude", {
      id: "claude",
      name: "Anthropic Claude",
      requiresApiKey: true,
      models: [
        {
          id: "claude-opus-4-20250514",
          name: "Claude 4 Opus - \uCD5C\uAC15 \uC131\uB2A5",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 0.045,
          // $15 input + $75 output / 2
          isNew: true
        },
        {
          id: "claude-sonnet-4-20250514",
          name: "Claude 4 Sonnet - \uADE0\uD615",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 9e-3,
          // $3 input + $15 output / 2
          isNew: true
        },
        {
          id: "claude-3-7-sonnet-20250219",
          name: "Claude 3.7 Sonnet - \uCD5C\uC2E0",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 9e-3,
          // $3 input + $15 output / 2
          isNew: true
        },
        {
          id: "claude-3-5-sonnet-20250107",
          name: "Claude 3.5 Sonnet (Jan 2025)",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 9e-3
          // $3 input + $15 output / 2
        },
        {
          id: "claude-3-5-sonnet-20241022",
          name: "Claude 3.5 Sonnet",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 9e-3
          // $3 input + $15 output / 2
        },
        {
          id: "claude-3-5-haiku-20241022",
          name: "Claude 3.5 Haiku - \uBE60\uB978 \uC751\uB2F5",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 75e-5
          // $0.25 input + $1.25 output / 2
        },
        {
          id: "claude-3-opus-20240229",
          name: "Claude 3 Opus",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 0.045
          // $15 input + $75 output / 2
        },
        {
          id: "claude-3-haiku-20240307",
          name: "Claude 3 Haiku",
          maxTokens: 2e5,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 75e-5
          // $0.25 input + $1.25 output / 2
        }
      ]
    });
    this.providers.set("gemini", {
      id: "gemini",
      name: "Google Gemini",
      requiresApiKey: true,
      models: [
        {
          id: "gemini-2.5-pro-preview-05-06",
          name: "Gemini 2.5 Pro Preview - \uCD5C\uAC15 \uC131\uB2A5",
          maxTokens: 1048576,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 3125e-6,
          isNew: true
        },
        {
          id: "gemini-2.5-flash",
          name: "Gemini 2.5 Flash - \uC548\uC815 \uBC84\uC804",
          maxTokens: 1048576,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 1875e-7,
          isNew: true
        },
        {
          id: "gemini-2.5-flash-preview-05-20",
          name: "Gemini 2.5 Flash Preview - \uCD5C\uC2E0",
          maxTokens: 1048576,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 1875e-7,
          isNew: true
        },
        {
          id: "gemini-2.0-flash",
          name: "Gemini 2.0 Flash - \uCD5C\uC2E0",
          maxTokens: 1e6,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 185e-6,
          // $0.07 input + $0.30 output / 2
          isNew: true
        },
        {
          id: "gemini-1.5-flash",
          name: "Gemini 1.5 Flash - \uC548\uC815\uC801",
          maxTokens: 1048576,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 1875e-7
          // $0.075 input + $0.30 output / 2
        },
        {
          id: "gemini-1.5-flash-8b",
          name: "Gemini 1.5 Flash-8B - \uBE60\uB984",
          maxTokens: 1048576,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 75e-6
        },
        {
          id: "gemini-1.5-pro",
          name: "Gemini 1.5 Pro",
          maxTokens: 2097152,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 3125e-6
          // $1.25 input + $5 output / 2
        }
      ]
    });
    this.providers.set("ollama", {
      id: "ollama",
      name: "Ollama (Local)",
      requiresApiKey: false,
      isLocal: true,
      models: [
        {
          id: "llama3",
          name: "Llama 3",
          maxTokens: 8192,
          supportedLanguages: ["korean", "english"]
        },
        {
          id: "mistral",
          name: "Mistral",
          maxTokens: 8192,
          supportedLanguages: ["korean", "english"]
        },
        {
          id: "gemma",
          name: "Gemma",
          maxTokens: 8192,
          supportedLanguages: ["korean", "english"]
        }
      ]
    });
    this.providers.set("cohere", {
      id: "cohere",
      name: "Cohere",
      requiresApiKey: true,
      models: [
        {
          id: "command-r-plus",
          name: "Command R+",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 59375e-7
          // $2.375 input + $9.50 output / 2
        },
        {
          id: "command-r",
          name: "Command R",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 375e-6
          // $0.15 input + $0.60 output / 2
        }
      ]
    });
    this.providers.set("groq", {
      id: "groq",
      name: "Groq",
      requiresApiKey: true,
      models: [
        {
          id: "llama-3.3-70b-versatile",
          name: "Llama 3.3 70B Versatile",
          maxTokens: 32768,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 69e-5
          // $0.59 input + $0.79 output / 2
        },
        {
          id: "llama-3.1-70b-versatile",
          name: "Llama 3.1 70B Versatile",
          maxTokens: 131072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 69e-5
          // $0.59 input + $0.79 output / 2
        },
        {
          id: "llama-3.1-8b-instant",
          name: "Llama 3.1 8B Instant",
          maxTokens: 131072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 65e-6
          // $0.05 input + $0.08 output / 2
        },
        {
          id: "mixtral-8x7b-32768",
          name: "Mixtral 8x7B",
          maxTokens: 32768,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 24e-5
        }
      ]
    });
    this.providers.set("mistral", {
      id: "mistral",
      name: "Mistral AI",
      requiresApiKey: true,
      models: [
        {
          id: "mistral-large-latest",
          name: "Mistral Large",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 4e-3
          // $2.00 input + $6.00 output / 2
        },
        {
          id: "mistral-medium-latest",
          name: "Mistral Medium",
          maxTokens: 32e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 27e-4
        },
        {
          id: "codestral-latest",
          name: "Codestral",
          maxTokens: 32e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 6e-4
          // $0.30 input + $0.90 output / 2
        }
      ]
    });
    this.providers.set("perplexity", {
      id: "perplexity",
      name: "Perplexity",
      requiresApiKey: true,
      models: [
        {
          id: "llama-3.1-sonar-small-128k-online",
          name: "Llama 3.1 Sonar Small (Online)",
          maxTokens: 127072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 2e-4
        },
        {
          id: "llama-3.1-sonar-large-128k-online",
          name: "Llama 3.1 Sonar Large (Online)",
          maxTokens: 127072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 1e-3
        },
        {
          id: "llama-3.1-sonar-huge-128k-online",
          name: "Llama 3.1 Sonar Huge (Online)",
          maxTokens: 127072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 5e-3
        }
      ]
    });
    this.providers.set("xai", {
      id: "xai",
      name: "xAI",
      requiresApiKey: true,
      models: [
        {
          id: "grok-beta",
          name: "Grok Beta",
          maxTokens: 131072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 5e-3
        }
      ]
    });
    this.providers.set("together", {
      id: "together",
      name: "Together AI",
      requiresApiKey: true,
      models: [
        {
          id: "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo",
          name: "Llama 3.1 70B Instruct Turbo",
          maxTokens: 131072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 88e-5
        },
        {
          id: "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
          name: "Llama 3.1 8B Instruct Turbo",
          maxTokens: 131072,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 18e-5
        },
        {
          id: "mistralai/Mixtral-8x7B-Instruct-v0.1",
          name: "Mixtral 8x7B Instruct",
          maxTokens: 32768,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 6e-4
        }
      ]
    });
    this.providers.set("deepseek", {
      id: "deepseek",
      name: "DeepSeek",
      requiresApiKey: true,
      models: [
        {
          id: "deepseek-v3-0324",
          name: "DeepSeek V3",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 21e-5,
          // $0.14 input + $0.28 output / 2
          isNew: true
        },
        {
          id: "deepseek-r1-0528",
          name: "DeepSeek R1",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 137e-5,
          // $0.55 input + $2.19 output / 2
          isNew: true
        }
      ]
    });
    this.providers.set("grok", {
      id: "grok",
      name: "xAI Grok",
      requiresApiKey: true,
      models: [
        {
          id: "grok-3",
          name: "Grok 3",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 2e-3,
          isNew: true
        },
        {
          id: "grok-3-mini",
          name: "Grok 3 Mini",
          maxTokens: 128e3,
          supportedLanguages: ["korean", "english"],
          costPer1kTokens: 1e-3,
          isNew: true
        }
      ]
    });
  }
  async generateCompletion(request) {
    const cacheKey = this.generateCacheKey(request);
    if (request.settings.cacheEnabled && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() < cached.latencyMs + 3e5) {
        return { ...cached, cached: true };
      }
    }
    if (this.requestQueue.has(cacheKey)) {
      return await this.requestQueue.get(cacheKey);
    }
    const completionPromise = this.performCompletion(request);
    this.requestQueue.set(cacheKey, completionPromise);
    try {
      const result = await completionPromise;
      if (request.settings.cacheEnabled) {
        this.cache.set(cacheKey, result);
      }
      return result;
    } catch (error) {
      throw error;
    } finally {
      this.requestQueue.delete(cacheKey);
    }
  }
  async performCompletion(request) {
    const startTime = Date.now();
    const provider = this.providers.get(request.settings.selectedProvider);
    if (!provider) {
      throw new Error(`Unknown provider: ${request.settings.selectedProvider}`);
    }
    const model = provider.models.find((m) => m.id === request.settings.selectedModel);
    if (!model) {
      throw new Error(`Unknown model: ${request.settings.selectedModel}`);
    }
    if (provider.requiresApiKey && !request.settings.apiKeys[provider.id]) {
      throw new Error(`API key required for ${provider.name}`);
    }
    let response;
    try {
      switch (provider.id) {
        case "openai":
          response = await this.callOpenAI(request, provider, model);
          break;
        case "claude":
          response = await this.callClaude(request, provider, model);
          break;
        case "gemini":
          response = await this.callGemini(request, provider, model);
          break;
        case "ollama":
          response = await this.callOllama(request, provider, model);
          break;
        case "cohere":
          response = await this.callCohere(request, provider, model);
          break;
        case "groq":
          response = await this.callGroq(request, provider, model);
          break;
        case "mistral":
          response = await this.callMistral(request, provider, model);
          break;
        case "perplexity":
          response = await this.callPerplexity(request, provider, model);
          break;
        case "xai":
          response = await this.callXAI(request, provider, model);
          break;
        case "together":
          response = await this.callTogether(request, provider, model);
          break;
        case "deepseek":
          response = await this.callDeepSeek(request, provider, model);
          break;
        case "grok":
          response = await this.callGrok(request, provider, model);
          break;
        default:
          throw new Error(`Unsupported provider: ${provider.id}`);
      }
      response.latencyMs = Date.now() - startTime;
      this.updateUsageStats(request.settings, response, provider.id, model.id);
      return response;
    } catch (error) {
      console.error(`AI completion error:`, error);
      throw new Error(`AI completion failed: ${(error == null ? void 0 : error.message) || "Unknown error"}`);
    }
  }
  async callOpenAI(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const isReasoningModel = model.id.startsWith("o1");
    if (isReasoningModel) {
      return this.callOpenAIReasoning(request, provider, model);
    }
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, model.maxTokens),
      temperature: request.settings.temperature,
      stop: ["\n\n", "```"],
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.openai.com/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.openai}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("OpenAI API call failed:", error);
      throw error;
    }
  }
  async callOpenAIReasoning(request, provider, model) {
    var _a, _b, _c, _d;
    const prompt = this.buildPrompt(request);
    const systemPrompt = this.getSystemPrompt(request.settings);
    const minTokensForO1 = 4e3;
    const maxTokens = Math.max(minTokensForO1, request.settings.maxCompletionLength * 10);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "user",
          content: `${systemPrompt}

${prompt}`
        }
      ],
      max_completion_tokens: Math.min(maxTokens, model.maxTokens)
    };
    try {
      const requestParam = {
        url: "https://api.openai.com/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.openai}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`OpenAI Reasoning API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      const choice = data.choices[0];
      const content = (_a = choice.message) == null ? void 0 : _a.content;
      if (request.settings.showDebugInfo) {
        console.log("=== OpenAI Reasoning API \uC751\uB2F5 \uBD84\uC11D ===");
        console.log("\uC804\uCCB4 \uC751\uB2F5:", data);
        console.log("choice:", choice);
        console.log("content:", content);
        console.log("content \uD0C0\uC785:", typeof content);
        console.log("content \uAE38\uC774:", (content == null ? void 0 : content.length) || 0);
        console.log("finish_reason:", choice.finish_reason);
        console.log("usage:", data.usage);
        console.log("reasoning_tokens:", ((_c = (_b = data.usage) == null ? void 0 : _b.completion_tokens_details) == null ? void 0 : _c.reasoning_tokens) || 0);
        console.log("\uC694\uCCAD\uD55C max_completion_tokens:", requestData.max_completion_tokens);
      }
      if (!content || content.trim().length === 0) {
        throw new Error("AI\uAC00 \uBE48 \uC751\uB2F5\uC744 \uBC18\uD658\uD588\uC2B5\uB2C8\uB2E4. \uB2E4\uB978 \uBAA8\uB378\uC744 \uC2DC\uB3C4\uD574\uBCF4\uC138\uC694.");
      }
      return {
        completion: content.trim(),
        confidence: 0.9,
        model: model.id,
        tokensUsed: ((_d = data.usage) == null ? void 0 : _d.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("OpenAI Reasoning API call failed:", error);
      throw error;
    }
  }
  async callClaude(request, provider, model) {
    var _a, _b, _c;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      max_tokens: Math.min(request.settings.maxCompletionLength, 4096),
      temperature: request.settings.temperature,
      system: this.getSystemPrompt(request.settings),
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    };
    if (request.settings.showDebugInfo) {
      console.log("Claude API Request:", {
        url: "https://api.anthropic.com/v1/messages",
        model: model.id,
        maxTokens: requestData.max_tokens,
        prompt: prompt.substring(0, 100) + "...",
        apiKeyPresent: !!request.settings.apiKeys.claude,
        requestDataSize: JSON.stringify(requestData).length
      });
    }
    try {
      const requestParam = {
        url: "https://api.anthropic.com/v1/messages",
        method: "POST",
        headers: {
          "x-api-key": request.settings.apiKeys.claude,
          "Content-Type": "application/json",
          "anthropic-version": "2023-06-01",
          "Accept": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      if (request.settings.showDebugInfo) {
        console.log("Making Claude API request...");
      }
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (request.settings.showDebugInfo) {
        console.log("Claude API Response Status:", response.status);
      }
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        if (request.settings.showDebugInfo) {
          console.error("Claude API Error Response:", errorText);
        }
        throw new Error(`Claude API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (request.settings.showDebugInfo) {
        console.log("Claude API Response received");
        console.log("content \uC874\uC7AC:", !!data.content);
        console.log("content \uAE38\uC774:", ((_a = data.content) == null ? void 0 : _a.length) || 0);
      }
      let extractedText = "";
      if (data.content && data.content.length > 0) {
        extractedText = data.content[0].text.trim();
      }
      if (!extractedText) {
        throw new Error("Claude API\uC5D0\uC11C \uD14D\uC2A4\uD2B8\uB97C \uCD94\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
      }
      return {
        completion: extractedText,
        confidence: 0.9,
        model: model.id,
        tokensUsed: (((_b = data.usage) == null ? void 0 : _b.input_tokens) || 0) + (((_c = data.usage) == null ? void 0 : _c.output_tokens) || 0),
        latencyMs: 0
      };
    } catch (error) {
      if (request.settings.showDebugInfo) {
        console.error("Claude API call failed:", error);
        console.error("Error details:", {
          name: error.name,
          message: error.message,
          type: typeof error
        });
      }
      if (error.message.includes("401")) {
        throw new Error("API \uD0A4\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
      } else if (error.message.includes("429")) {
        throw new Error("API \uC694\uCCAD \uD55C\uB3C4\uB97C \uCD08\uACFC\uD588\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.");
      } else if (error.message.includes("network") || error.message.includes("fetch")) {
        throw new Error("\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      }
      throw error;
    }
  }
  async callGemini(request, provider, model) {
    var _a, _b, _c, _d, _e, _f;
    const prompt = this.buildPrompt(request);
    const systemPrompt = this.getSystemPrompt(request.settings);
    const requestData = {
      contents: [
        {
          parts: [
            {
              text: `${systemPrompt}

${prompt}`
            }
          ]
        }
      ],
      generationConfig: {
        temperature: request.settings.temperature,
        maxOutputTokens: this.getOptimalMaxTokens(model.id, request.settings.maxCompletionLength),
        candidateCount: 1
      }
    };
    if (request.settings.showDebugInfo) {
      console.log("Gemini API Request:", {
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model.id}:generateContent`,
        model: model.id,
        prompt: prompt.substring(0, 100) + "...",
        apiKeyPresent: !!request.settings.apiKeys.gemini,
        requestDataSize: JSON.stringify(requestData).length
      });
    }
    try {
      const requestParam = {
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model.id}:generateContent?key=${request.settings.apiKeys.gemini}`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      if (request.settings.showDebugInfo) {
        console.log("Making Gemini request with Obsidian requestUrl...");
      }
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (request.settings.showDebugInfo) {
        console.log("Gemini API Response Status:", response.status);
        console.log("Gemini API Response received");
      }
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        if (request.settings.showDebugInfo) {
          console.error("Gemini API Error Response:", errorText);
        }
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (request.settings.showDebugInfo) {
        console.log("=== Gemini API \uC0C1\uC138 \uC751\uB2F5 \uBD84\uC11D ===");
        console.log("\uC804\uCCB4 \uC751\uB2F5 \uB370\uC774\uD130:", data);
        console.log("candidates \uC874\uC7AC:", !!data.candidates);
        console.log("candidates \uAE38\uC774:", ((_a = data.candidates) == null ? void 0 : _a.length) || 0);
        if (data.candidates && data.candidates.length > 0) {
          const candidate2 = data.candidates[0];
          console.log("\uCCAB \uBC88\uC9F8 candidate:", candidate2);
          console.log("candidate.content \uC874\uC7AC:", !!candidate2.content);
          console.log("candidate.content:", candidate2.content);
          if (candidate2.content) {
            console.log("content.parts \uC874\uC7AC:", !!candidate2.content.parts);
            console.log("content.parts \uAE38\uC774:", ((_b = candidate2.content.parts) == null ? void 0 : _b.length) || 0);
            console.log("content.parts:", candidate2.content.parts);
            if (candidate2.content.parts && candidate2.content.parts.length > 0) {
              console.log("\uCCAB \uBC88\uC9F8 part:", candidate2.content.parts[0]);
              console.log("\uCCAB \uBC88\uC9F8 part.text:", candidate2.content.parts[0].text);
            }
          }
          console.log("candidate.text \uC874\uC7AC:", !!candidate2.text);
          console.log("candidate.output \uC874\uC7AC:", !!candidate2.output);
          console.log("candidate\uC758 \uBAA8\uB4E0 \uD0A4\uB4E4:", Object.keys(candidate2));
        }
        console.log("promptFeedback:", data.promptFeedback);
        console.log("usageMetadata:", data.usageMetadata);
        console.log("thoughtsTokenCount:", (_c = data.usageMetadata) == null ? void 0 : _c.thoughtsTokenCount);
        console.log("=== \uC751\uB2F5 \uBD84\uC11D \uC644\uB8CC ===");
      }
      if (!data.candidates || data.candidates.length === 0) {
        if (request.settings.showDebugInfo) {
          console.error("\u274C candidates\uAC00 \uC5C6\uAC70\uB098 \uBE48 \uBC30\uC5F4\uC785\uB2C8\uB2E4");
          console.log("data.promptFeedback:", data.promptFeedback);
        }
        throw new Error("No completion generated - no candidates in response");
      }
      const candidate = data.candidates[0];
      let extractedText = "";
      if (request.settings.showDebugInfo) {
        console.log("=== Candidate \uBD84\uC11D ===");
        console.log("finishReason:", candidate.finishReason);
        console.log("candidate\uC758 \uBAA8\uB4E0 \uD0A4\uB4E4:", Object.keys(candidate));
        if (candidate.finishReason === "MAX_TOKENS") {
          console.warn("\u26A0\uFE0F MAX_TOKENS\uC73C\uB85C \uC778\uD574 \uC751\uB2F5\uC774 \uC798\uB838\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4");
        }
      }
      if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
        const part = candidate.content.parts[0];
        if (part.text !== void 0) {
          extractedText = part.text || "";
          if (request.settings.showDebugInfo) {
            console.log("\u2705 content.parts[0].text\uC5D0\uC11C \uD14D\uC2A4\uD2B8 \uCD94\uCD9C:", extractedText.length > 0 ? "\uC131\uACF5" : "\uBE48 \uD14D\uC2A4\uD2B8");
          }
        }
      } else if (candidate.text !== void 0) {
        extractedText = candidate.text || "";
        if (request.settings.showDebugInfo) {
          console.log("\u2705 candidate.text\uC5D0\uC11C \uD14D\uC2A4\uD2B8 \uCD94\uCD9C:", extractedText.length > 0 ? "\uC131\uACF5" : "\uBE48 \uD14D\uC2A4\uD2B8");
        }
      } else if (candidate.output !== void 0) {
        extractedText = candidate.output || "";
        if (request.settings.showDebugInfo) {
          console.log("\u2705 candidate.output\uC5D0\uC11C \uD14D\uC2A4\uD2B8 \uCD94\uCD9C:", extractedText.length > 0 ? "\uC131\uACF5" : "\uBE48 \uD14D\uC2A4\uD2B8");
        }
      }
      if (candidate.finishReason === "MAX_TOKENS") {
        if (request.settings.showDebugInfo) {
          console.log("\u26A0\uFE0F MAX_TOKENS \uAC10\uC9C0 - \uBD80\uBD84 \uACB0\uACFC \uC0AC\uC6A9 \uC2DC\uB3C4");
          console.log("\u{1F9E0} thinking tokens \uC815\uBCF4:", ((_d = data.usageMetadata) == null ? void 0 : _d.thoughtsTokenCount) || "N/A");
        }
        if (!extractedText || extractedText.trim().length === 0) {
          const thoughtsCount = ((_e = data.usageMetadata) == null ? void 0 : _e.thoughtsTokenCount) || 0;
          if (thoughtsCount > 0) {
            extractedText = `[Gemini 2.5 \uBAA8\uB378\uC774 ${thoughtsCount}\uAC1C\uC758 thinking tokens\uC744 \uC0AC\uC6A9\uD558\uC5EC \uD1A0\uD070 \uD55C\uB3C4\uC5D0 \uB3C4\uB2EC\uD588\uC2B5\uB2C8\uB2E4. \uB354 \uAE34 \uC751\uB2F5\uC744 \uC6D0\uD558\uC2DC\uBA74 \uC124\uC815\uC5D0\uC11C maxCompletionLength\uB97C \uC99D\uAC00\uC2DC\uCF1C \uC8FC\uC138\uC694.]`;
          } else {
            extractedText = "[\uC751\uB2F5\uC774 \uD1A0\uD070 \uD55C\uB3C4\uB85C \uC778\uD574 \uC798\uB838\uC2B5\uB2C8\uB2E4]";
          }
        }
      } else if (!extractedText || extractedText.trim().length === 0) {
        if (request.settings.showDebugInfo) {
          console.error("\u274C \uBAA8\uB4E0 \uBC29\uBC95\uC73C\uB85C \uD14D\uC2A4\uD2B8 \uCD94\uCD9C \uC2E4\uD328");
          console.log("candidate \uAD6C\uC870:", JSON.stringify(candidate, null, 2));
        }
        throw new Error("No completion generated - no extractable text found");
      }
      if (request.settings.showDebugInfo) {
        console.log("\u2705 \uCD5C\uC885 \uC131\uACF5\uC801\uC73C\uB85C \uD14D\uC2A4\uD2B8 \uCD94\uCD9C:", extractedText.substring(0, 100) + "...");
      }
      const totalTokensUsed = ((_f = data.usageMetadata) == null ? void 0 : _f.totalTokenCount) || 0;
      if (request.settings.showDebugInfo) {
        console.log("\u{1F522} \uD1A0\uD070 \uC0AC\uC6A9\uB7C9:", totalTokensUsed);
      }
      return {
        completion: extractedText.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: totalTokensUsed,
        latencyMs: 0
      };
    } catch (error) {
      if (request.settings.showDebugInfo) {
        console.error("Gemini API call failed:", error);
        console.error("Error details:", {
          name: error.name,
          message: error.message,
          type: typeof error
        });
      }
      if (error.message.includes("401") || error.message.includes("403")) {
        throw new Error("Gemini API \uD0A4\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
      } else if (error.message.includes("429")) {
        throw new Error("Gemini API \uC694\uCCAD \uD55C\uB3C4\uB97C \uCD08\uACFC\uD588\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.");
      } else if (error.message.includes("400")) {
        throw new Error("Gemini API \uC694\uCCAD \uD615\uC2DD\uC5D0 \uBB38\uC81C\uAC00 \uC788\uC2B5\uB2C8\uB2E4.");
      } else if (error.message.includes("network") || error.message.includes("fetch")) {
        throw new Error("\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      }
      throw error;
    }
  }
  async callOllama(request, provider, model) {
    var _a, _b;
    const prompt = this.buildPrompt(request);
    const systemPrompt = this.getSystemPrompt(request.settings);
    const requestData = {
      model: model.id,
      prompt: `${systemPrompt}

${prompt}`,
      stream: false,
      options: {
        temperature: request.settings.temperature,
        num_predict: Math.min(request.settings.maxCompletionLength, 1e3)
      }
    };
    try {
      const requestParam = {
        url: "http://localhost:11434/api/generate",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Ollama API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.response) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.response.trim(),
        confidence: 0.7,
        model: model.id,
        tokensUsed: 0,
        // Ollama doesn't provide token count
        latencyMs: 0
      };
    } catch (error) {
      if (((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("ECONNREFUSED")) || ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("fetch"))) {
        throw new Error("Ollama is not running. Please start Ollama server.");
      }
      console.error("Ollama API call failed:", error);
      throw error;
    }
  }
  buildPrompt(request) {
    const { context, settings } = request;
    let prompt = `\uB2E4\uC74C\uC740 \uC635\uC2DC\uB514\uC5B8\uC5D0\uC11C \uC791\uC131 \uC911\uC778 \uBB38\uC11C\uC758 \uC77C\uBD80\uC785\uB2C8\uB2E4.

\uD30C\uC77C\uBA85: ${context.fileName}
\uD0DC\uADF8: ${context.tags.join(", ") || "\uC5C6\uC74C"}
\uC791\uC131 \uC2A4\uD0C0\uC77C: ${settings.writingStyle}
\uC5B8\uC5B4: ${settings.language}

\uD604\uC7AC\uAE4C\uC9C0 \uC791\uC131\uB41C \uB0B4\uC6A9:
${context.beforeCursor}`;
    if (context.inCodeBlock) {
      prompt += `

\uD604\uC7AC \uCF54\uB4DC \uBE14\uB85D \uC548\uC5D0 \uC788\uC2B5\uB2C8\uB2E4. \uCF54\uB4DC \uD615\uC2DD\uC5D0 \uB9DE\uB294 \uC644\uC131\uC744 \uC81C\uACF5\uD574\uC8FC\uC138\uC694.`;
    } else if (context.inMathBlock) {
      prompt += `

\uD604\uC7AC \uC218\uD559 \uBE14\uB85D \uC548\uC5D0 \uC788\uC2B5\uB2C8\uB2E4. \uC218\uD559 \uD45C\uAE30\uBC95\uC5D0 \uB9DE\uB294 \uC644\uC131\uC744 \uC81C\uACF5\uD574\uC8FC\uC138\uC694.`;
    } else if (context.inCallout) {
      prompt += `

\uD604\uC7AC \uCF5C\uC544\uC6C3 \uBE14\uB85D \uC548\uC5D0 \uC788\uC2B5\uB2C8\uB2E4.`;
    }
    prompt += `

\uC704 \uB0B4\uC6A9\uC758 \uC790\uC5F0\uC2A4\uB7EC\uC6B4 \uB2E4\uC74C \uBD80\uBD84\uC744 ${settings.completionType === "sentence" ? "\uD55C \uBB38\uC7A5" : settings.completionType === "paragraph" ? "\uD55C \uBB38\uB2E8" : "\uC801\uC808\uD55C \uAE38\uC774\uB85C"} \uC644\uC131\uD574\uC8FC\uC138\uC694. \uAE30\uC874 \uBB38\uCCB4\uC640 \uD1A4\uC744 \uC720\uC9C0\uD558\uACE0, \uB17C\uB9AC\uC801 \uD750\uB984\uC744 \uC774\uC5B4\uAC00\uC138\uC694.`;
    return prompt;
  }
  getSystemPrompt(settings) {
    const basePrompt = `\uB2F9\uC2E0\uC740 \uC635\uC2DC\uB514\uC5B8\uC5D0\uC11C \uD559\uC2B5\uACFC \uC791\uBB38\uC744 \uB3C4\uC640\uC8FC\uB294 AI \uC5B4\uC2DC\uC2A4\uD134\uD2B8\uC785\uB2C8\uB2E4.`;
    let stylePrompt = "";
    if (settings.writingStyle === "custom" && settings.selectedCustomStyle) {
      const customStyle = settings.customWritingStyles.find((style) => style.id === settings.selectedCustomStyle);
      if (customStyle) {
        stylePrompt = customStyle.systemPrompt;
        if (customStyle.examples && customStyle.examples.length > 0) {
          stylePrompt += `

\uB2E4\uC74C\uC740 \uC774 \uC2A4\uD0C0\uC77C\uC758 \uC608\uC2DC\uB4E4\uC785\uB2C8\uB2E4:
${customStyle.examples.map((example, index) => `${index + 1}. ${example}`).join("\n")}`;
        }
      } else {
        stylePrompt = "\uCE5C\uADFC\uD558\uACE0 \uC790\uC5F0\uC2A4\uB7EC\uC6B4 \uB9D0\uD22C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694.";
      }
    } else {
      switch (settings.writingStyle) {
        case "academic":
          stylePrompt = "\uD559\uC220\uC801\uC774\uACE0 \uC815\uD655\uD55C \uD45C\uD604\uC744 \uC0AC\uC6A9\uD558\uC138\uC694.";
          break;
        case "casual":
          stylePrompt = "\uCE5C\uADFC\uD558\uACE0 \uC790\uC5F0\uC2A4\uB7EC\uC6B4 \uB9D0\uD22C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694.";
          break;
        case "creative":
          stylePrompt = "\uCC3D\uC758\uC801\uC774\uACE0 \uD765\uBBF8\uB85C\uC6B4 \uD45C\uD604\uC744 \uC0AC\uC6A9\uD558\uC138\uC694.";
          break;
        case "technical":
          stylePrompt = "\uAE30\uC220\uC801\uC774\uACE0 \uBA85\uD655\uD55C \uC124\uBA85\uC744 \uC0AC\uC6A9\uD558\uC138\uC694.";
          break;
        default:
          stylePrompt = "\uCE5C\uADFC\uD558\uACE0 \uC790\uC5F0\uC2A4\uB7EC\uC6B4 \uB9D0\uD22C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694.";
      }
    }
    return `${basePrompt} ${stylePrompt}

\uADDC\uCE59:
1. \uC635\uC2DC\uB514\uC5B8 \uB9C8\uD06C\uB2E4\uC6B4 \uBB38\uBC95\uC744 \uC900\uC218\uD558\uC138\uC694
2. \uAE30\uC874 \uB0B4\uC6A9\uC758 \uB9E5\uB77D\uACFC \uD750\uB984\uC744 \uC720\uC9C0\uD558\uC138\uC694
3. \uC644\uC131\uD560 \uBD80\uBD84\uB9CC \uC81C\uACF5\uD558\uACE0, \uAE30\uC874 \uB0B4\uC6A9\uC744 \uBC18\uBCF5\uD558\uC9C0 \uB9C8\uC138\uC694
4. \uC790\uC5F0\uC2A4\uB7FD\uACE0 \uC720\uC6A9\uD55C \uC644\uC131\uC744 \uC81C\uACF5\uD558\uC138\uC694
5. \uB108\uBB34 \uAE38\uAC70\uB098 \uC9E7\uC9C0 \uC54A\uAC8C \uC801\uC808\uD55C \uAE38\uC774\uB85C \uC644\uC131\uD558\uC138\uC694`;
  }
  getOptimalMaxTokens(modelId, requestedTokens) {
    if (modelId.includes("2.5")) {
      if (modelId.includes("pro")) {
        return Math.min(requestedTokens * 10, 16384);
      } else if (modelId.includes("flash")) {
        return Math.min(requestedTokens * 8, 12288);
      }
    }
    return Math.min(requestedTokens, 2048);
  }
  generateCacheKey(request) {
    const key = `${request.settings.selectedProvider}-${request.settings.selectedModel}-${request.context.beforeCursor.slice(-200)}-${request.settings.temperature}`;
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      const char = key.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36).slice(0, 32);
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
  getProvider(id) {
    return this.providers.get(id);
  }
  clearCache() {
    this.cache.clear();
  }
  getCacheSize() {
    return this.cache.size;
  }
  updateUsageStats(settings, response, providerId, modelId) {
    const stats = settings.usageStats;
    const now = new Date();
    const today = now.toISOString().split("T")[0];
    const week = this.getWeekKey(now);
    const month = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    stats.totalCompletions += 1;
    stats.totalTokensUsed += response.tokensUsed;
    const provider = this.getProvider(providerId);
    const model = provider == null ? void 0 : provider.models.find((m) => m.id === modelId);
    const cost = (model == null ? void 0 : model.costPer1kTokens) ? response.tokensUsed / 1e3 * model.costPer1kTokens : 0;
    stats.totalCost += cost;
    const totalLatency = stats.averageLatency * (stats.totalCompletions - 1) + response.latencyMs;
    stats.averageLatency = totalLatency / stats.totalCompletions;
    if (!stats.providerUsage[providerId]) {
      stats.providerUsage[providerId] = 0;
    }
    stats.providerUsage[providerId] += response.tokensUsed;
    const modelKey = `${providerId}:${modelId}`;
    if (!stats.modelUsage[modelKey]) {
      stats.modelUsage[modelKey] = 0;
    }
    stats.modelUsage[modelKey] += response.tokensUsed;
    if (!stats.dailyUsage[today]) {
      stats.dailyUsage[today] = { tokens: 0, cost: 0 };
    }
    stats.dailyUsage[today].tokens += response.tokensUsed;
    stats.dailyUsage[today].cost += cost;
    if (!stats.weeklyUsage[week]) {
      stats.weeklyUsage[week] = { tokens: 0, cost: 0 };
    }
    stats.weeklyUsage[week].tokens += response.tokensUsed;
    stats.weeklyUsage[week].cost += cost;
    if (!stats.monthlyUsage[month]) {
      stats.monthlyUsage[month] = { tokens: 0, cost: 0 };
    }
    stats.monthlyUsage[month].tokens += response.tokensUsed;
    stats.monthlyUsage[month].cost += cost;
  }
  getWeekKey(date) {
    const year = date.getFullYear();
    const firstDay = new Date(year, 0, 1);
    const days = Math.floor((date.getTime() - firstDay.getTime()) / (24 * 60 * 60 * 1e3));
    const week = Math.ceil((days + firstDay.getDay() + 1) / 7);
    return `${year}-W${String(week).padStart(2, "0")}`;
  }
  async callCohere(request, provider, model) {
    var _a, _b, _c, _d;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      message: prompt,
      temperature: request.settings.temperature,
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      stop_sequences: ["\n\n"],
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.cohere.ai/v1/chat",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.cohere}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Cohere API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.text) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.text.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_b = (_a = data.meta) == null ? void 0 : _a.tokens) == null ? void 0 : _b.input_tokens) + ((_d = (_c = data.meta) == null ? void 0 : _c.tokens) == null ? void 0 : _d.output_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Cohere API call failed:", error);
      throw error;
    }
  }
  async callGroq(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      temperature: request.settings.temperature,
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.groq.com/openai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.groq}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Groq API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Groq API call failed:", error);
      throw error;
    }
  }
  async callMistral(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      temperature: request.settings.temperature,
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.mistral.ai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.mistral}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Mistral API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Mistral API call failed:", error);
      throw error;
    }
  }
  async callPerplexity(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      temperature: request.settings.temperature,
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.perplexity.ai/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.perplexity}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Perplexity API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Perplexity API call failed:", error);
      throw error;
    }
  }
  async callXAI(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      temperature: request.settings.temperature,
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.x.ai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.xai}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`xAI API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("xAI API call failed:", error);
      throw error;
    }
  }
  async callTogether(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, 4e3),
      temperature: request.settings.temperature,
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.together.xyz/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.together}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Together API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Together API call failed:", error);
      throw error;
    }
  }
  async callDeepSeek(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, model.maxTokens),
      temperature: request.settings.temperature,
      stop: ["\n\n"],
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.deepseek.com/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.deepseek}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`DeepSeek API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.85,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("DeepSeek API call failed:", error);
      throw error;
    }
  }
  async callGrok(request, provider, model) {
    var _a;
    const prompt = this.buildPrompt(request);
    const requestData = {
      model: model.id,
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt(request.settings)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: Math.min(request.settings.maxCompletionLength, model.maxTokens),
      temperature: request.settings.temperature,
      stop: ["\n\n"],
      stream: false
    };
    try {
      const requestParam = {
        url: "https://api.x.ai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${request.settings.apiKeys.grok}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData),
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(requestParam);
      if (response.status !== 200) {
        const errorText = typeof response.text === "string" ? response.text : JSON.stringify(response.json);
        throw new Error(`Grok API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No completion generated");
      }
      return {
        completion: data.choices[0].message.content.trim(),
        confidence: 0.8,
        model: model.id,
        tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
        latencyMs: 0
      };
    } catch (error) {
      console.error("Grok API call failed:", error);
      throw error;
    }
  }
};

// src/editor-handler.ts
var EditorHandler = class {
  constructor() {
    this.editHistory = [];
    this.lastEditTime = 0;
    this.debounceTimer = null;
    this.editHistory = [];
  }
  analyzeContext(editor, file, settings) {
    const cursor = editor.getCursor();
    const doc = editor.getDoc();
    const totalLines = doc.lineCount();
    const beforeCursor = doc.getRange({ line: 0, ch: 0 }, cursor);
    const afterCursor = doc.getRange(cursor, { line: totalLines - 1, ch: doc.getLine(totalLines - 1).length });
    const currentLine = doc.getLine(cursor.line);
    const paragraph = this.extractParagraph(doc, cursor.line);
    const fileName = (file == null ? void 0 : file.name) || "Untitled";
    const fileType = (file == null ? void 0 : file.extension) || "md";
    const content = doc.getValue();
    const tags = this.extractTags(content);
    const frontmatter = this.extractFrontmatter(content);
    const context = {
      beforeCursor,
      afterCursor,
      currentLine,
      paragraph,
      fileName,
      fileType,
      tags,
      frontmatter,
      wordCount: beforeCursor.split(/\s+/).length,
      isMarkdownContext: fileType === "md",
      inCodeBlock: this.isInCodeBlock(beforeCursor, cursor.line, doc),
      inMathBlock: this.isInMathBlock(beforeCursor),
      inCallout: this.isInCallout(beforeCursor),
      recentEdits: this.getRecentEdits()
    };
    return context;
  }
  extractParagraph(doc, currentLine) {
    let startLine = currentLine;
    let endLine = currentLine;
    while (startLine > 0 && doc.getLine(startLine - 1).trim() !== "") {
      startLine--;
    }
    while (endLine < doc.lineCount() - 1 && doc.getLine(endLine + 1).trim() !== "") {
      endLine++;
    }
    let paragraph = "";
    for (let i = startLine; i <= endLine; i++) {
      paragraph += doc.getLine(i);
      if (i < endLine)
        paragraph += "\n";
    }
    return paragraph;
  }
  extractTags(content) {
    const tagRegex = /#[\w가-힣-/]+/g;
    const matches = content.match(tagRegex);
    return matches ? matches.map((tag) => tag.substring(1)) : [];
  }
  extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match)
      return {};
    try {
      const frontmatterText = match[1];
      const frontmatter = {};
      const lines = frontmatterText.split("\n");
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          const value = line.substring(colonIndex + 1).trim();
          frontmatter[key] = value.replace(/^["']|["']$/g, "");
        }
      }
      return frontmatter;
    } catch (error) {
      console.warn("Failed to parse frontmatter:", error);
      return {};
    }
  }
  isInCodeBlock(beforeCursor, currentLine, doc) {
    const lines = beforeCursor.split("\n");
    let inCodeBlock = false;
    for (const line of lines) {
      if (line.trim().startsWith("```")) {
        inCodeBlock = !inCodeBlock;
      }
    }
    return inCodeBlock;
  }
  isInMathBlock(beforeCursor) {
    const mathBlockRegex = /\$\$/g;
    const matches = beforeCursor.match(mathBlockRegex);
    return matches ? matches.length % 2 === 1 : false;
  }
  isInCallout(beforeCursor) {
    const lines = beforeCursor.split("\n");
    const lastLine = lines[lines.length - 1];
    const prevLine = lines.length > 1 ? lines[lines.length - 2] : "";
    return lastLine.trim().startsWith("> [!") || prevLine.trim().startsWith("> [!");
  }
  recordEdit(type, content, position) {
    const edit = {
      timestamp: Date.now(),
      type,
      content,
      position
    };
    this.editHistory.push(edit);
    this.lastEditTime = Date.now();
    if (this.editHistory.length > 50) {
      this.editHistory = this.editHistory.slice(-50);
    }
  }
  getRecentEdits() {
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1e3;
    return this.editHistory.filter((edit) => edit.timestamp > fiveMinutesAgo);
  }
  shouldTriggerCompletion(editor, settings, lastCompletionTime = 0) {
    console.log("\u{1F50D} EditorHandler.shouldTriggerCompletion \uC2DC\uC791");
    const timeSinceLastEdit = Date.now() - this.lastEditTime;
    console.log("\u23F1\uFE0F \uB9C8\uC9C0\uB9C9 \uD3B8\uC9D1 \uD6C4 \uC2DC\uAC04:", timeSinceLastEdit + "ms");
    if (timeSinceLastEdit < Math.min(settings.delayMs, 200)) {
      console.log("\u274C \uD3B8\uC9D1 \uD6C4 \uC2DC\uAC04 \uBD80\uC871");
      return false;
    }
    const timeSinceLastCompletion = Date.now() - lastCompletionTime;
    console.log("\u23F1\uFE0F \uB9C8\uC9C0\uB9C9 \uC644\uC131 \uD6C4 \uC2DC\uAC04:", timeSinceLastCompletion + "ms");
    if (timeSinceLastCompletion < 2e3) {
      console.log("\u274C \uC644\uC131 \uD6C4 \uC2DC\uAC04 \uBD80\uC871");
      return false;
    }
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    const beforeCursor = currentLine.substring(0, cursor.ch);
    const minChars = Math.min(settings.minCharsBeforeCompletion, 3);
    console.log("\u{1F4DD} \uD604\uC7AC \uC904:", JSON.stringify(currentLine));
    console.log("\u{1F4DD} \uCEE4\uC11C \uC804 \uD14D\uC2A4\uD2B8:", JSON.stringify(beforeCursor));
    console.log("\u{1F4CF} \uCD5C\uC18C \uAE00\uC790 \uC218:", minChars, "/ \uD604\uC7AC:", beforeCursor.trim().length);
    if (beforeCursor.trim().length < minChars) {
      console.log("\u274C \uAE00\uC790 \uC218 \uBD80\uC871");
      return false;
    }
    console.log("\u2705 EditorHandler \uC870\uAC74 \uD1B5\uACFC!");
    return true;
  }
  detectLanguage(content) {
    const koreanRegex = /[가-힣]/g;
    const englishRegex = /[a-zA-Z]/g;
    const koreanMatches = content.match(koreanRegex);
    const englishMatches = content.match(englishRegex);
    const koreanCount = koreanMatches ? koreanMatches.length : 0;
    const englishCount = englishMatches ? englishMatches.length : 0;
    if (koreanCount === 0 && englishCount === 0) {
      return "english";
    }
    const totalCount = koreanCount + englishCount;
    const koreanRatio = koreanCount / totalCount;
    if (koreanRatio > 0.7) {
      return "korean";
    } else if (koreanRatio < 0.3) {
      return "english";
    } else {
      return "mixed";
    }
  }
  detectWritingContext(context) {
    const { beforeCursor, fileName, tags, frontmatter } = context;
    if (fileName.toLowerCase().includes("paper") || fileName.toLowerCase().includes("research")) {
      return "academic";
    }
    if (fileName.toLowerCase().includes("note") || fileName.toLowerCase().includes("memo")) {
      return "note-taking";
    }
    const academicTags = ["paper", "research", "study", "academic", "\uB17C\uBB38", "\uC5F0\uAD6C", "\uD559\uC220"];
    const creativeTags = ["creative", "writing", "story", "fiction", "\uCC3D\uC791", "\uC18C\uC124"];
    const technicalTags = ["code", "programming", "tech", "tutorial", "\uCF54\uB529", "\uD504\uB85C\uADF8\uB798\uBC0D"];
    for (const tag of tags) {
      if (academicTags.some((t) => tag.toLowerCase().includes(t))) {
        return "academic";
      }
      if (creativeTags.some((t) => tag.toLowerCase().includes(t))) {
        return "creative";
      }
      if (technicalTags.some((t) => tag.toLowerCase().includes(t))) {
        return "technical";
      }
    }
    const content = beforeCursor.toLowerCase();
    if (content.includes("abstract") || content.includes("introduction") || content.includes("methodology") || content.includes("conclusion") || content.includes("\uCD08\uB85D") || content.includes("\uC11C\uB860") || content.includes("\uACB0\uB860")) {
      return "academic";
    }
    if (content.includes("- ") || content.includes("* ") || content.includes("1. ")) {
      return "list";
    }
    return "general";
  }
  clearEditHistory() {
    this.editHistory = [];
  }
  getLastEditTime() {
    return this.lastEditTime;
  }
  setDebounceTimer(timer) {
    if (this.debounceTimer !== null) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = timer;
  }
  clearDebounceTimer() {
    if (this.debounceTimer !== null) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
  }
};

// src/ghost-text.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var addGhostText = import_state.StateEffect.define({
  map: (val, change) => ({
    ...val,
    from: change.mapPos(val.from)
  })
});
var clearGhostText = import_state.StateEffect.define();
var GhostTextWidget = class extends import_view.WidgetType {
  constructor(text, completion) {
    super();
    this.text = text;
    this.completion = completion;
  }
  toDOM() {
    const element = document.createElement("span");
    element.className = "ai-ghost-text";
    element.textContent = this.text;
    element.title = `AI \uC644\uC131 (${this.completion.model}): ${this.completion.completion}`;
    element.style.cssText = `
			color: #888;
			opacity: 0.5;
			font-style: italic;
			pointer-events: none;
			user-select: none;
			background: transparent;
		`;
    console.log("Ghost Text Widget \uC0DD\uC131\uB428:", this.text);
    return element;
  }
  ignoreEvent() {
    return true;
  }
};
var ghostTextField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(decorations, tr) {
    decorations = decorations.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(addGhostText)) {
        console.log("Ghost Text \uCD94\uAC00:", e.value);
        const widget = new GhostTextWidget(e.value.text, e.value.completion);
        const decoration = import_view.Decoration.widget({
          widget,
          side: 1,
          block: false
        });
        decorations = decorations.update({
          add: [decoration.range(e.value.from)]
        });
      } else if (e.is(clearGhostText)) {
        if (decorations.size > 0) {
          console.log("Ghost Text \uC81C\uAC70 (StateField)");
        }
        decorations = import_view.Decoration.none;
      }
    }
    return decorations;
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
var ghostTextPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.lastTriggerTime = 0;
    this.triggerTimeout = null;
    this.hasGhostText = false;
    this.lastClearTime = 0;
    console.log("\u{1F527} Ghost Text ViewPlugin \uCD08\uAE30\uD654\uB428 - EditorView:", !!view);
    console.log("\u{1F4CD} \uD604\uC7AC \uBB38\uC11C \uAE38\uC774:", view.state.doc.length);
  }
  update(update) {
    const now = Date.now();
    if (update.docChanged) {
      console.log("\uBB38\uC11C \uBCC0\uACBD \uAC10\uC9C0\uB428");
      if (this.hasGhostText && now - this.lastClearTime > 100) {
        this.clearGhostTextAsync();
        this.lastClearTime = now;
      }
      if (this.triggerTimeout) {
        clearTimeout(this.triggerTimeout);
        this.triggerTimeout = null;
      }
      if (now - this.lastTriggerTime > 2e3) {
        this.triggerTimeout = setTimeout(() => {
          this.triggerAutoCompletion(update);
        }, 800);
      }
    }
    if (update.selectionSet && !update.docChanged) {
      const selection = update.state.selection.main;
      const prevSelection = update.startState.selection.main;
      if (Math.abs(selection.head - prevSelection.head) > 1) {
        if (this.hasGhostText && now - this.lastClearTime > 200) {
          this.clearGhostTextAsync();
          this.lastClearTime = now;
        }
      }
    }
  }
  clearGhostTextAsync() {
    setTimeout(() => {
      this.view.dispatch({
        effects: clearGhostText.of(null)
      });
      if (this.hasGhostText) {
        console.log("Ghost Text \uC81C\uAC70\uB428 (ViewPlugin)");
      }
      this.hasGhostText = false;
    }, 0);
  }
  triggerAutoCompletion(update) {
    try {
      console.log("\uC790\uB3D9\uC644\uC131 \uD2B8\uB9AC\uAC70 \uC2DC\uB3C4");
      const selection = update.state.selection.main;
      const pos = selection.head;
      const doc = update.state.doc;
      const line = doc.lineAt(pos);
      const lineNumber = line.number - 1;
      const character = pos - line.from;
      const beforeCursor = doc.sliceString(Math.max(0, pos - 300), pos);
      const lineText = line.text;
      console.log("\uCEE4\uC11C \uC704\uCE58:", { lineNumber, character, lineText });
      console.log("\uC774\uC804 \uD14D\uC2A4\uD2B8:", beforeCursor.substring(Math.max(0, beforeCursor.length - 50)));
      if (this.shouldTriggerCompletion(beforeCursor, lineText, character)) {
        console.log("\uC790\uB3D9\uC644\uC131 \uC870\uAC74 \uCDA9\uC871, \uC774\uBCA4\uD2B8 \uBC1C\uC0DD");
        const event = new CustomEvent("aiAutoCompletionTrigger", {
          detail: {
            view: this.view,
            position: { line: lineNumber, ch: character },
            beforeCursor,
            lineText
          }
        });
        document.dispatchEvent(event);
        this.lastTriggerTime = Date.now();
      } else {
        console.log("\uC790\uB3D9\uC644\uC131 \uC870\uAC74 \uBD88\uCDA9\uC871");
      }
    } catch (error) {
      console.error("\uC790\uB3D9\uC644\uC131 \uD2B8\uB9AC\uAC70 \uC5D0\uB7EC:", error);
    }
  }
  shouldTriggerCompletion(beforeCursor, lineText, character) {
    console.log("=== \uC790\uB3D9\uC644\uC131 \uC870\uAC74 \uCCB4\uD06C \uC2DC\uC791 ===");
    console.log("beforeCursor:", JSON.stringify(beforeCursor));
    console.log("lineText:", JSON.stringify(lineText));
    console.log("character:", character);
    console.log("beforeCursor.trim().length:", beforeCursor.trim().length);
    if (beforeCursor.trim().length < 3) {
      console.log("\u274C \uD14D\uC2A4\uD2B8\uAC00 \uB108\uBB34 \uC9E7\uC74C:", beforeCursor.trim().length);
      return false;
    }
    const timeSinceLastTrigger = Date.now() - this.lastTriggerTime;
    if (timeSinceLastTrigger < 1e3) {
      console.log("\u274C \uB108\uBB34 \uCD5C\uADFC\uC5D0 \uC644\uC131\uB428:", timeSinceLastTrigger + "ms");
      return false;
    }
    const trimmed = beforeCursor.trim();
    if (trimmed.length === 0) {
      console.log("\u274C \uACF5\uBC31\uB9CC \uC788\uC74C");
      return false;
    }
    console.log("\u2705 \uC790\uB3D9\uC644\uC131 \uC870\uAC74 \uD1B5\uACFC! (3\uAE00\uC790 \uC774\uC0C1)");
    console.log("=== \uC790\uB3D9\uC644\uC131 \uC870\uAC74 \uCCB4\uD06C \uB05D ===");
    return true;
  }
});
var ghostTextExtension = [
  ghostTextField,
  ghostTextPlugin
];
var GhostTextManager = class {
  constructor() {
    this.editorView = null;
    this.currentGhostText = null;
    this.setupStyles();
  }
  setupStyles() {
    const style = document.createElement("style");
    style.textContent = `
			.ai-ghost-text {
				color: #888 !important;
				opacity: 0.5 !important;
				font-style: italic !important;
				pointer-events: none !important;
				user-select: none !important;
				background: transparent !important;
				border: none !important;
				margin: 0 !important;
				padding: 0 !important;
				font-family: inherit !important;
				font-size: inherit !important;
				line-height: inherit !important;
			}

			.ai-ghost-text-loading {
				animation: ghost-text-pulse 1.5s ease-in-out infinite;
			}

			@keyframes ghost-text-pulse {
				0%, 100% { opacity: 0.5; }
				50% { opacity: 0.2; }
			}
		`;
    document.head.appendChild(style);
    console.log("Ghost Text \uC2A4\uD0C0\uC77C \uCD94\uAC00\uB428");
  }
  showGhostText(editor, completion, position) {
    console.log("Ghost Text \uD45C\uC2DC \uC694\uCCAD:", completion.completion.substring(0, 50) + "...");
    const editorView = editor.cm;
    if (!editorView) {
      console.error("EditorView\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC74C");
      return;
    }
    this.editorView = editorView;
    const doc = editorView.state.doc;
    const line = doc.line(position.line + 1);
    const from = line.from + position.ch;
    const firstLine = completion.completion.split("\n")[0];
    const displayText = firstLine;
    this.currentGhostText = displayText;
    editorView.dispatch({
      effects: [
        clearGhostText.of(null),
        addGhostText.of({
          from,
          text: displayText,
          completion
        })
      ]
    });
    const plugin = editorView.plugin(ghostTextPlugin);
    if (plugin) {
      plugin.hasGhostText = true;
    }
    console.log("Ghost Text \uB514\uC2A4\uD328\uCE58\uB428:", { from, displayText });
    setTimeout(() => {
      if (this.currentGhostText === displayText) {
        this.clearGhostText();
      }
    }, 3e4);
  }
  clearGhostText() {
    if (this.editorView) {
      console.log("Ghost Text \uC81C\uAC70 (GhostTextManager)");
      this.editorView.dispatch({
        effects: clearGhostText.of(null)
      });
      const plugin = this.editorView.plugin(ghostTextPlugin);
      if (plugin) {
        plugin.hasGhostText = false;
      }
    }
    this.currentGhostText = null;
    this.editorView = null;
  }
  hasGhostText() {
    return this.currentGhostText !== null;
  }
  getCurrentGhostText() {
    return this.currentGhostText;
  }
  acceptGhostText() {
    const text = this.currentGhostText;
    this.clearGhostText();
    return text;
  }
  showLoadingIndicator(editor, position) {
    const loadingCompletion = {
      completion: "...",
      confidence: 0,
      model: "loading",
      tokensUsed: 0,
      latencyMs: 0
    };
    this.showGhostText(editor, loadingCompletion, position);
  }
  updateGhostText(newText) {
    this.clearGhostText();
  }
  handleKeyNavigation(key, editor) {
    if (!this.hasGhostText()) {
      return false;
    }
    switch (key) {
      case "ArrowRight":
        const acceptedText = this.acceptGhostText();
        if (acceptedText) {
          const cursor = editor.getCursor();
          const currentLine = editor.getLine(cursor.line);
          const beforeCursor = currentLine.substring(0, cursor.ch);
          let cleanedText = acceptedText;
          if (cleanedText.includes("...")) {
            return true;
          }
          cleanedText = cleanedText.trim();
          const trimmedBeforeCursor = beforeCursor.trim();
          if (trimmedBeforeCursor.length > 0) {
            const lastSegment = trimmedBeforeCursor.split(/\s+/).pop() || "";
            if (lastSegment.length > 0 && cleanedText.toLowerCase().startsWith(lastSegment.toLowerCase())) {
              cleanedText = cleanedText.substring(lastSegment.length);
            }
          }
          if (cleanedText.length > 0) {
            const insertPos = cursor;
            editor.replaceRange(cleanedText, insertPos, insertPos);
            const newCursor = {
              line: insertPos.line,
              ch: insertPos.ch + cleanedText.length
            };
            editor.setCursor(newCursor);
            console.log("Ghost Text \uC218\uB77D\uB428 (\u2192 \uD0A4):", {
              original: acceptedText,
              cleaned: cleanedText,
              beforeCursor,
              lastSegment: trimmedBeforeCursor.split(/\s+/).pop()
            });
          }
        }
        return true;
      case "Escape":
        this.clearGhostText();
        console.log("Ghost Text \uAC70\uBD80\uB428");
        return true;
      default:
        return false;
    }
  }
  destroy() {
    this.clearGhostText();
    this.currentGhostText = null;
    this.editorView = null;
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  // Provider settings
  selectedProvider: "claude",
  selectedModel: "claude-3-5-sonnet-20250107",
  apiKeys: {},
  // Completion behavior
  delayMs: 1500,
  maxCompletionLength: 100,
  temperature: 0.7,
  contextWindow: 2e3,
  // Writing settings
  language: "korean",
  writingStyle: "casual",
  completionType: "auto",
  customWritingStyles: [],
  selectedCustomStyle: void 0,
  // Feature toggles
  enabled: true,
  autoDetectContext: true,
  showDebugInfo: false,
  enableOfflineMode: false,
  showDetailedStats: false,
  // Advanced settings
  minCharsBeforeCompletion: 10,
  maxRetries: 3,
  timeoutMs: 1e4,
  cacheEnabled: true,
  // Usage tracking
  usageStats: {
    totalCompletions: 0,
    totalTokensUsed: 0,
    totalCost: 0,
    averageLatency: 0,
    providerUsage: {},
    modelUsage: {},
    dailyUsage: {},
    weeklyUsage: {},
    monthlyUsage: {}
  }
};
var AIWritingAssistantSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, aiService) {
    super(app, plugin);
    this.plugin = plugin;
    this.aiService = aiService;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "AI Writing Assistant \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uD50C\uB7EC\uADF8\uC778 \uD65C\uC131\uD654").setDesc("AI \uC644\uC131 \uAE30\uB2A5\uC744 \uCF1C\uAC70\uB098 \uB055\uB2C8\uB2E4").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.enableCompletion();
      } else {
        this.plugin.disableCompletion();
      }
    }));
    containerEl.createEl("h2", { text: "AI \uBAA8\uB378 \uC124\uC815" });
    const providers = this.aiService.getProviders();
    const providerOptions = {};
    providers.forEach((provider) => {
      providerOptions[provider.id] = provider.name;
    });
    new import_obsidian2.Setting(containerEl).setName("AI \uC81C\uACF5\uC790").setDesc("\uC0AC\uC6A9\uD560 AI \uC11C\uBE44\uC2A4\uB97C \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions(providerOptions).setValue(this.plugin.settings.selectedProvider).onChange(async (value) => {
      this.plugin.settings.selectedProvider = value;
      const provider = this.aiService.getProvider(value);
      if (provider && provider.models.length > 0) {
        this.plugin.settings.selectedModel = provider.models[0].id;
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    const selectedProvider = this.aiService.getProvider(this.plugin.settings.selectedProvider);
    if (selectedProvider) {
      const modelOptions = {};
      selectedProvider.models.forEach((model) => {
        let modelName = model.name;
        if (model.isNew)
          modelName += " \u{1F195}";
        if (model.isExperimental)
          modelName += " \u{1F9EA}";
        modelOptions[model.id] = modelName;
      });
      new import_obsidian2.Setting(containerEl).setName("AI \uBAA8\uB378").setDesc("\uC0AC\uC6A9\uD560 AI \uBAA8\uB378\uC744 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions(modelOptions).setValue(this.plugin.settings.selectedModel).onChange(async (value) => {
        this.plugin.settings.selectedModel = value;
        await this.plugin.saveSettings();
      }));
      if (selectedProvider.requiresApiKey) {
        new import_obsidian2.Setting(containerEl).setName(`${selectedProvider.name} API \uD0A4`).setDesc(`${selectedProvider.name} \uC11C\uBE44\uC2A4\uB97C \uC0AC\uC6A9\uD558\uB824\uBA74 API \uD0A4\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4`).addText((text) => text.setPlaceholder("API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694").setValue(this.plugin.settings.apiKeys[selectedProvider.id] || "").onChange(async (value) => {
          this.plugin.settings.apiKeys[selectedProvider.id] = value;
          await this.plugin.saveSettings();
        }));
      }
    }
    containerEl.createEl("h2", { text: "\uC791\uBB38 \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uC5B8\uC5B4").setDesc("\uC8FC\uB85C \uC0AC\uC6A9\uD560 \uC5B8\uC5B4\uB97C \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions({
      "korean": "\uD55C\uAD6D\uC5B4",
      "english": "English",
      "auto": "\uC790\uB3D9 \uAC10\uC9C0"
    }).setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
    }));
    const styleOptions = {
      "academic": "\uD559\uC220\uC801",
      "casual": "\uC77C\uC0C1\uC801",
      "creative": "\uCC3D\uC758\uC801",
      "technical": "\uAE30\uC220\uC801",
      "custom": "\uAC1C\uC778 \uB9DE\uCDA4 \uC2A4\uD0C0\uC77C"
    };
    new import_obsidian2.Setting(containerEl).setName("\uC791\uBB38 \uC2A4\uD0C0\uC77C").setDesc("\uC120\uD638\uD558\uB294 \uAE00\uC4F0\uAE30 \uC2A4\uD0C0\uC77C\uC744 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions(styleOptions).setValue(this.plugin.settings.writingStyle).onChange(async (value) => {
      this.plugin.settings.writingStyle = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.writingStyle === "custom") {
      if (this.plugin.settings.customWritingStyles.length > 0) {
        const customStyleOptions = {};
        this.plugin.settings.customWritingStyles.forEach((style) => {
          customStyleOptions[style.id] = style.name;
        });
        new import_obsidian2.Setting(containerEl).setName("\uC0AC\uC6A9\uD560 \uAC1C\uC778 \uC2A4\uD0C0\uC77C").setDesc("\uC0AC\uC6A9\uD560 \uAC1C\uC778 \uB9DE\uCDA4 \uC2A4\uD0C0\uC77C\uC744 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions(customStyleOptions).setValue(this.plugin.settings.selectedCustomStyle || "").onChange(async (value) => {
          this.plugin.settings.selectedCustomStyle = value;
          await this.plugin.saveSettings();
        }));
      }
      new import_obsidian2.Setting(containerEl).setName("\uC0C8 \uAC1C\uC778 \uC2A4\uD0C0\uC77C \uCD94\uAC00").setDesc("\uB098\uB9CC\uC758 \uC791\uBB38 \uC2A4\uD0C0\uC77C\uC744 \uB9CC\uB4E4\uC5B4\uBCF4\uC138\uC694").addButton((button) => button.setButtonText("\uC0C8 \uC2A4\uD0C0\uC77C \uCD94\uAC00").setCta().onClick(() => {
        new CustomStyleModal(this.app, this.plugin, (style) => {
          this.plugin.settings.customWritingStyles.push(style);
          if (!this.plugin.settings.selectedCustomStyle) {
            this.plugin.settings.selectedCustomStyle = style.id;
          }
          this.plugin.saveSettings();
          this.display();
        }).open();
      }));
      this.plugin.settings.customWritingStyles.forEach((style, index) => {
        new import_obsidian2.Setting(containerEl).setName(style.name).setDesc(`${style.description} (\uD615\uC2DD: ${style.formality}, \uCC3D\uC758\uC131: ${Math.round(style.creativity * 100)}%)`).addButton((button) => button.setButtonText("\uD3B8\uC9D1").onClick(() => {
          new CustomStyleModal(this.app, this.plugin, (updatedStyle) => {
            this.plugin.settings.customWritingStyles[index] = updatedStyle;
            this.plugin.saveSettings();
            this.display();
          }, style).open();
        })).addButton((button) => button.setButtonText("\uC0AD\uC81C").setWarning().onClick(async () => {
          this.plugin.settings.customWritingStyles.splice(index, 1);
          if (this.plugin.settings.selectedCustomStyle === style.id) {
            this.plugin.settings.selectedCustomStyle = this.plugin.settings.customWritingStyles.length > 0 ? this.plugin.settings.customWritingStyles[0].id : void 0;
          }
          await this.plugin.saveSettings();
          this.display();
        }));
      });
    }
    new import_obsidian2.Setting(containerEl).setName("\uC644\uC131 \uC720\uD615").setDesc("AI\uAC00 \uC81C\uC548\uD560 \uC644\uC131\uC758 \uAE38\uC774\uB97C \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => dropdown.addOptions({
      "sentence": "\uBB38\uC7A5 \uB2E8\uC704",
      "paragraph": "\uBB38\uB2E8 \uB2E8\uC704",
      "bullet": "\uBAA9\uB85D \uD56D\uBAA9",
      "auto": "\uC790\uB3D9 \uD310\uB2E8"
    }).setValue(this.plugin.settings.completionType).onChange(async (value) => {
      this.plugin.settings.completionType = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\uB3D9\uC791 \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uC644\uC131 \uC9C0\uC5F0 \uC2DC\uAC04").setDesc("\uC785\uB825 \uC911\uC9C0 \uD6C4 AI \uC644\uC131\uC744 \uC2DC\uC791\uD558\uAE30\uAE4C\uC9C0\uC758 \uC2DC\uAC04 (\uBC00\uB9AC\uCD08)").addSlider((slider) => slider.setLimits(500, 5e3, 250).setValue(this.plugin.settings.delayMs).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.delayMs = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uCD5C\uB300 \uC644\uC131 \uAE38\uC774").setDesc("AI\uAC00 \uC0DD\uC131\uD560 \uC644\uC131\uC758 \uCD5C\uB300 \uB2E8\uC5B4 \uC218").addSlider((slider) => slider.setLimits(20, 500, 20).setValue(this.plugin.settings.maxCompletionLength).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxCompletionLength = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uCC3D\uC758\uC131 \uC218\uC900").setDesc("AI \uC751\uB2F5\uC758 \uCC3D\uC758\uC131 (0.0 = \uBCF4\uC218\uC801, 1.0 = \uCC3D\uC758\uC801)").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uCD5C\uC18C \uC785\uB825 \uAE00\uC790 \uC218").setDesc("AI \uC644\uC131\uC744 \uC2DC\uC791\uD558\uAE30 \uC704\uD55C \uCD5C\uC18C \uAE00\uC790 \uC218").addSlider((slider) => slider.setLimits(5, 50, 5).setValue(this.plugin.settings.minCharsBeforeCompletion).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.minCharsBeforeCompletion = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\uACE0\uAE09 \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uCEE8\uD14D\uC2A4\uD2B8 \uC790\uB3D9 \uAC10\uC9C0").setDesc("\uC8FC\uBCC0 \uBB38\uB9E5\uC744 \uBD84\uC11D\uD558\uC5EC \uC644\uC131\uC744 \uAC1C\uC120\uD569\uB2C8\uB2E4").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoDetectContext).onChange(async (value) => {
      this.plugin.settings.autoDetectContext = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uCE90\uC2DC \uD65C\uC131\uD654").setDesc("\uAC19\uC740 \uC644\uC131 \uC694\uCCAD\uC744 \uBE60\uB974\uAC8C \uCC98\uB9AC\uD569\uB2C8\uB2E4").addToggle((toggle) => toggle.setValue(this.plugin.settings.cacheEnabled).onChange(async (value) => {
      this.plugin.settings.cacheEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uB514\uBC84\uADF8 \uC815\uBCF4 \uD45C\uC2DC").setDesc("\uCF58\uC194\uC5D0 \uB514\uBC84\uADF8 \uC815\uBCF4\uB97C \uCD9C\uB825\uD569\uB2C8\uB2E4").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDebugInfo).onChange(async (value) => {
      this.plugin.settings.showDebugInfo = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u{1F4CA} \uC0AC\uC6A9\uB7C9 \uD1B5\uACC4" });
    this.addUsageStatsSection(containerEl);
    containerEl.createEl("div", {
      text: "AI Writing Assistant v1.0.0",
      cls: "setting-item-description"
    });
  }
  addUsageStatsSection(containerEl) {
    const stats = this.plugin.settings.usageStats;
    const totalSection = containerEl.createDiv("usage-stats-section");
    totalSection.createEl("h3", { text: "\u{1F522} \uC804\uCCB4 \uC0AC\uC6A9\uB7C9" });
    new import_obsidian2.Setting(totalSection).setName("\uCD1D \uC644\uC131 \uD69F\uC218").setDesc(`${stats.totalCompletions.toLocaleString()}\uD68C`).setClass("usage-stat-item");
    new import_obsidian2.Setting(totalSection).setName("\uCD1D \uD1A0\uD070 \uC0AC\uC6A9\uB7C9").setDesc(`${stats.totalTokensUsed.toLocaleString()} \uD1A0\uD070`).setClass("usage-stat-item");
    new import_obsidian2.Setting(totalSection).setName("\uCD1D \uC608\uC0C1 \uBE44\uC6A9").setDesc(`$${stats.totalCost.toFixed(4)} USD`).setClass("usage-stat-item");
    const warningDiv = totalSection.createDiv("usage-warning");
    warningDiv.innerHTML = `
			<div style="margin: 10px 0; padding: 10px; background-color: var(--background-modifier-warning); border-radius: 5px; border-left: 4px solid var(--color-orange);">
				<strong>\u26A0\uFE0F \uC8FC\uC758\uC0AC\uD56D:</strong><br>
				\u2022 \uD45C\uC2DC\uB41C \uD1A0\uD070 \uBE44\uC6A9\uC740 <strong>\uB300\uB7B5\uC801\uC778 \uCD94\uC815\uCE58</strong>\uC785\uB2C8\uB2E4<br>
				\u2022 \uC2E4\uC81C \uC694\uAE08\uC740 \uAC01 API \uC81C\uACF5\uC790\uC758 \uC815\uD655\uD55C \uC694\uAE08\uC81C\uC5D0 \uB530\uB77C \uB2E4\uB97C \uC218 \uC788\uC2B5\uB2C8\uB2E4<br>
				\u2022 \uC815\uD655\uD55C \uBE44\uC6A9\uC740 \uAC01 \uC81C\uACF5\uC790\uC758 \uACF5\uC2DD \uB300\uC2DC\uBCF4\uB4DC\uC5D0\uC11C \uD655\uC778\uD558\uC2DC\uAE30 \uBC14\uB78D\uB2C8\uB2E4
			</div>
		`;
    new import_obsidian2.Setting(containerEl).setName("\uC138\uBD80 \uC0AC\uC6A9\uB7C9 \uC815\uBCF4").setDesc(this.plugin.settings.showDetailedStats ? "\uC138\uBD80 \uC815\uBCF4\uB97C \uC228\uAE30\uB824\uBA74 \uD074\uB9AD\uD558\uC138\uC694" : "\uC81C\uACF5\uC790\uBCC4, \uC77C\uBCC4, \uC6D4\uBCC4 \uC0AC\uC6A9\uB7C9\uC744 \uBCF4\uB824\uBA74 \uD074\uB9AD\uD558\uC138\uC694").addButton((button) => button.setButtonText(this.plugin.settings.showDetailedStats ? "\u25B2 \uC138\uBD80 \uC815\uBCF4 \uC228\uAE30\uAE30" : "\u25BC \uC138\uBD80 \uC815\uBCF4 \uBCF4\uAE30").onClick(async () => {
      this.plugin.settings.showDetailedStats = !this.plugin.settings.showDetailedStats;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.showDetailedStats) {
      const detailsContainer = containerEl.createDiv("usage-details-container");
      detailsContainer.style.marginTop = "15px";
      detailsContainer.style.paddingLeft = "10px";
      detailsContainer.style.borderLeft = "2px solid var(--background-modifier-border)";
      new import_obsidian2.Setting(detailsContainer).setName("\uD3C9\uADE0 \uC751\uB2F5 \uC2DC\uAC04").setDesc(`${Math.round(stats.averageLatency)}ms`).setClass("usage-stat-item");
      if (Object.keys(stats.providerUsage).length > 0) {
        const providerSection = detailsContainer.createDiv("usage-stats-section");
        providerSection.createEl("h3", { text: "\u{1F3E2} \uC81C\uACF5\uC790\uBCC4 \uC0AC\uC6A9\uB7C9" });
        for (const [providerId, tokens] of Object.entries(stats.providerUsage)) {
          const provider = this.aiService.getProvider(providerId);
          const providerName = provider ? provider.name : providerId;
          new import_obsidian2.Setting(providerSection).setName(providerName).setDesc(`${tokens.toLocaleString()} \uD1A0\uD070`).setClass("usage-stat-item");
        }
      }
      const recentDays = this.getRecentDays(7);
      if (recentDays.length > 0) {
        const recentSection = detailsContainer.createDiv("usage-stats-section");
        recentSection.createEl("h3", { text: "\u{1F4C5} \uCD5C\uADFC 7\uC77C \uC0AC\uC6A9\uB7C9" });
        for (const day of recentDays) {
          const dayStats = stats.dailyUsage[day.key];
          if (dayStats && (dayStats.tokens > 0 || dayStats.cost > 0)) {
            new import_obsidian2.Setting(recentSection).setName(day.label).setDesc(`${dayStats.tokens.toLocaleString()} \uD1A0\uD070 \u2022 $${dayStats.cost.toFixed(4)}`).setClass("usage-stat-item");
          }
        }
      }
      const recentMonths = this.getRecentMonths(3);
      if (recentMonths.length > 0) {
        const monthlySection = detailsContainer.createDiv("usage-stats-section");
        monthlySection.createEl("h3", { text: "\u{1F4CA} \uC6D4\uBCC4 \uC0AC\uC6A9\uB7C9" });
        for (const month of recentMonths) {
          const monthStats = stats.monthlyUsage[month.key];
          if (monthStats && (monthStats.tokens > 0 || monthStats.cost > 0)) {
            new import_obsidian2.Setting(monthlySection).setName(month.label).setDesc(`${monthStats.tokens.toLocaleString()} \uD1A0\uD070 \u2022 $${monthStats.cost.toFixed(4)}`).setClass("usage-stat-item");
          }
        }
      }
    }
    new import_obsidian2.Setting(containerEl).setName("\uD1B5\uACC4 \uCD08\uAE30\uD654").setDesc("\uBAA8\uB4E0 \uC0AC\uC6A9\uB7C9 \uD1B5\uACC4\uB97C \uCD08\uAE30\uD654\uD569\uB2C8\uB2E4 (\uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4)").addButton((button) => button.setButtonText("\uD1B5\uACC4 \uCD08\uAE30\uD654").setWarning().onClick(async () => {
      this.plugin.settings.usageStats = {
        totalCompletions: 0,
        totalTokensUsed: 0,
        totalCost: 0,
        averageLatency: 0,
        providerUsage: {},
        modelUsage: {},
        dailyUsage: {},
        weeklyUsage: {},
        monthlyUsage: {}
      };
      await this.plugin.saveSettings();
      new import_obsidian2.Notice("\uC0AC\uC6A9\uB7C9 \uD1B5\uACC4\uAC00 \uCD08\uAE30\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      this.display();
    }));
  }
  getRecentDays(count) {
    const days = [];
    const now = new Date();
    for (let i = 0; i < count; i++) {
      const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1e3);
      const key = date.toISOString().split("T")[0];
      const label = i === 0 ? "\uC624\uB298" : i === 1 ? "\uC5B4\uC81C" : `${date.getMonth() + 1}/${date.getDate()}`;
      days.push({ key, label });
    }
    return days;
  }
  getRecentMonths(count) {
    const months = [];
    const now = new Date();
    for (let i = 0; i < count; i++) {
      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
      const label = i === 0 ? "\uC774\uBC88 \uB2EC" : i === 1 ? "\uC9C0\uB09C \uB2EC" : `${date.getFullYear()}\uB144 ${date.getMonth() + 1}\uC6D4`;
      months.push({ key, label });
    }
    return months;
  }
};
var CustomStyleModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, callback, editingStyle) {
    super(app);
    this.plugin = plugin;
    this.callback = callback;
    this.editingStyle = editingStyle;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.editingStyle ? "\uAC1C\uC778 \uC2A4\uD0C0\uC77C \uD3B8\uC9D1" : "\uC0C8 \uAC1C\uC778 \uC2A4\uD0C0\uC77C \uB9CC\uB4E4\uAE30" });
    new import_obsidian2.Setting(contentEl).setName("\uC2A4\uD0C0\uC77C \uC774\uB984").setDesc("\uC774 \uC2A4\uD0C0\uC77C\uC758 \uC774\uB984\uC744 \uC785\uB825\uD558\uC138\uC694").addText((text) => {
      var _a2;
      this.nameInput = text;
      text.setPlaceholder("\uC608: \uD559\uC220 \uB17C\uBB38 \uC2A4\uD0C0\uC77C").setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.name) || "");
    });
    new import_obsidian2.Setting(contentEl).setName("\uC2A4\uD0C0\uC77C \uC124\uBA85").setDesc("\uC774 \uC2A4\uD0C0\uC77C\uC5D0 \uB300\uD55C \uAC04\uB2E8\uD55C \uC124\uBA85\uC744 \uC785\uB825\uD558\uC138\uC694").addText((text) => {
      var _a2;
      this.descInput = text;
      text.setPlaceholder("\uC608: \uD559\uC220\uC801\uC774\uACE0 \uC815\uD655\uD55C \uD45C\uD604\uC744 \uC0AC\uC6A9").setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.description) || "");
    });
    new import_obsidian2.Setting(contentEl).setName("\uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8").setDesc("AI\uAC00 \uC774 \uC2A4\uD0C0\uC77C\uB85C \uAE00\uC744 \uC4F8 \uB54C \uB530\uB77C\uC57C \uD560 \uC9C0\uCE68\uC744 \uC785\uB825\uD558\uC138\uC694").addTextArea((text) => {
      var _a2;
      this.promptInput = text;
      text.setPlaceholder("\uC608: \uB2F9\uC2E0\uC740 \uD559\uC220\uC801\uC774\uACE0 \uC815\uD655\uD55C \uD55C\uAD6D\uC5B4\uB85C \uAE00\uC744 \uC791\uC131\uD569\uB2C8\uB2E4. \uC804\uBB38\uC6A9\uC5B4\uB97C \uC801\uC808\uD788 \uC0AC\uC6A9\uD558\uACE0, \uB17C\uB9AC\uC801\uC778 \uAD6C\uC870\uB97C \uC720\uC9C0\uD558\uBA70...").setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.systemPrompt) || "").inputEl.rows = 5;
    });
    new import_obsidian2.Setting(contentEl).setName("\uD1A4 & \uBD84\uC704\uAE30").setDesc("\uAE00\uC758 \uD1A4\uACFC \uBD84\uC704\uAE30\uB97C \uC124\uBA85\uD558\uC138\uC694").addText((text) => {
      var _a2;
      this.toneInput = text;
      text.setPlaceholder("\uC608: \uCC28\uBD84\uD558\uACE0 \uC2E0\uC911\uD55C").setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.tone) || "");
    });
    new import_obsidian2.Setting(contentEl).setName("\uACA9\uC2DD").setDesc("\uAE00\uC758 \uACA9\uC2DD \uC218\uC900\uC744 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => {
      var _a2;
      this.formalityDropdown = dropdown;
      dropdown.addOptions({
        "formal": "\uACA9\uC2DD \uC788\uC74C",
        "neutral": "\uBCF4\uD1B5",
        "informal": "\uACA9\uC2DD \uC5C6\uC74C"
      }).setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.formality) || "neutral");
    });
    new import_obsidian2.Setting(contentEl).setName("\uCC3D\uC758\uC131 \uC218\uC900").setDesc("0\uC5D0 \uAC00\uAE4C\uC6B8\uC218\uB85D \uC815\uD655\uD558\uACE0 \uC77C\uAD00\uB41C \uD45C\uD604, 1\uC5D0 \uAC00\uAE4C\uC6B8\uC218\uB85D \uCC3D\uC758\uC801\uC774\uACE0 \uB2E4\uC591\uD55C \uD45C\uD604").addSlider((slider) => {
      var _a2;
      this.creativitySlider = slider;
      slider.setLimits(0, 1, 0.1).setValue(((_a2 = this.editingStyle) == null ? void 0 : _a2.creativity) || 0.7).setDynamicTooltip();
    });
    const exampleContainer = contentEl.createDiv();
    exampleContainer.createEl("h3", { text: "\uC608\uC2DC \uBB38\uC7A5\uB4E4 (\uC120\uD0DD\uC0AC\uD56D)" });
    exampleContainer.createEl("p", {
      text: "\uC774 \uC2A4\uD0C0\uC77C\uB85C \uC791\uC131\uB41C \uC608\uC2DC \uBB38\uC7A5\uB4E4\uC744 \uCD94\uAC00\uD558\uBA74 AI\uAC00 \uB354 \uC815\uD655\uD558\uAC8C \uC2A4\uD0C0\uC77C\uC744 \uD559\uC2B5\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
      cls: "setting-item-description"
    });
    const examplesList = exampleContainer.createDiv();
    const examples = ((_a = this.editingStyle) == null ? void 0 : _a.examples) || [""];
    const updateExamples = () => {
      const inputs = examplesList.querySelectorAll("textarea");
      return Array.from(inputs).map((input) => input.value).filter((val) => val.trim());
    };
    const renderExamples = () => {
      examplesList.empty();
      examples.forEach((example, index) => {
        const exampleSetting = new import_obsidian2.Setting(examplesList).setName(`\uC608\uC2DC ${index + 1}`).addTextArea((text) => {
          text.setValue(example).setPlaceholder("\uC774 \uC2A4\uD0C0\uC77C\uB85C \uC791\uC131\uB41C \uC608\uC2DC \uBB38\uC7A5\uC744 \uC785\uB825\uD558\uC138\uC694");
          text.inputEl.rows = 2;
        }).addButton((button) => button.setButtonText("\uC0AD\uC81C").onClick(() => {
          examples.splice(index, 1);
          renderExamples();
        }));
      });
      new import_obsidian2.Setting(examplesList).addButton((button) => button.setButtonText("\uC608\uC2DC \uCD94\uAC00").onClick(() => {
        examples.push("");
        renderExamples();
      }));
    };
    renderExamples();
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    const saveButton = buttonContainer.createEl("button", { text: "\uC800\uC7A5", cls: "mod-cta" });
    const cancelButton = buttonContainer.createEl("button", { text: "\uCDE8\uC18C" });
    saveButton.onclick = () => {
      var _a2;
      const name = this.nameInput.getValue().trim();
      const description = this.descInput.getValue().trim();
      const systemPrompt = this.promptInput.getValue().trim();
      const tone = this.toneInput.getValue().trim();
      if (!name || !description || !systemPrompt) {
        return;
      }
      const style = {
        id: ((_a2 = this.editingStyle) == null ? void 0 : _a2.id) || `custom-${Date.now()}`,
        name,
        description,
        systemPrompt,
        tone,
        formality: this.formalityDropdown.getValue(),
        creativity: this.creativitySlider.getValue(),
        examples: updateExamples()
      };
      this.callback(style);
      this.close();
    };
    cancelButton.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var AIWritingAssistantPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.lastCompletionTime = 0;
    this.isProcessingCompletion = false;
    this.statusBarItem = null;
  }
  async onload() {
    console.log("\u{1F680} AI Writing Assistant Plugin \uB85C\uB529 \uC2DC\uC791");
    await this.loadSettings();
    console.log("\u2699\uFE0F \uC124\uC815 \uB85C\uB4DC \uC644\uB8CC:", this.settings.enabled);
    this.aiService = new AIService();
    this.editorHandler = new EditorHandler();
    this.ghostTextManager = new GhostTextManager();
    console.log("\u{1F4DD} Ghost Text Extension \uB4F1\uB85D \uC911...");
    this.registerEditorExtension(ghostTextExtension);
    console.log("\u2705 Ghost Text Extension \uB4F1\uB85D \uC644\uB8CC");
    this.addSettingTab(new AIWritingAssistantSettingsTab(
      this.app,
      this,
      this.aiService
    ));
    this.setupEditorHandlers();
    this.addCommands();
    this.setupStatusBar();
    if (this.settings.enabled) {
      this.enableCompletion();
    }
    console.log("AI Writing Assistant Plugin loaded successfully");
  }
  async onunload() {
    console.log("Unloading AI Writing Assistant Plugin");
    this.disableCompletion();
    this.ghostTextManager.destroy();
    if (this.autoCompletionTriggerHandler) {
      document.removeEventListener("aiAutoCompletionTrigger", this.autoCompletionTriggerHandler);
    }
    if (this.statusBarItem) {
      this.statusBarItem.remove();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  setupEditorHandlers() {
    console.log("\u{1F3AF} \uC5D0\uB514\uD130 \uD578\uB4E4\uB7EC \uC124\uC815 \uC2DC\uC791");
    this.autoCompletionTriggerHandler = this.onAutoCompletionTrigger.bind(this);
    document.addEventListener("aiAutoCompletionTrigger", this.autoCompletionTriggerHandler);
    console.log("\u{1F4E1} \uCEE4\uC2A4\uD140 \uC774\uBCA4\uD2B8 \uB9AC\uC2A4\uB108 \uB4F1\uB85D\uB428: aiAutoCompletionTrigger");
    this.registerDomEvent(document, "keydown", this.onKeyDown.bind(this));
    console.log("\u2328\uFE0F \uD0A4\uBCF4\uB4DC \uC774\uBCA4\uD2B8 \uB9AC\uC2A4\uB108 \uB4F1\uB85D\uB428");
    console.log("\u2705 \uC5D0\uB514\uD130 \uD578\uB4E4\uB7EC \uC124\uC815 \uC644\uB8CC (CodeMirror 6 \uBC29\uC2DD)");
  }
  async onAutoCompletionTrigger(event) {
    const customEvent = event;
    console.log("\uC790\uB3D9\uC644\uC131 \uC774\uBCA4\uD2B8 \uC218\uC2E0\uB428:", customEvent.detail);
    if (!this.settings.enabled || this.isProcessingCompletion) {
      console.log("\uC790\uB3D9\uC644\uC131 \uBE44\uD65C\uC131\uD654 \uB610\uB294 \uCC98\uB9AC \uC911");
      return;
    }
    const { view, position, beforeCursor, lineText } = customEvent.detail;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      console.log("\uD65C\uC131 \uB9C8\uD06C\uB2E4\uC6B4 \uBDF0 \uC5C6\uC74C");
      return;
    }
    const editor = activeView.editor;
    if (this.editorHandler.shouldTriggerCompletion(
      editor,
      this.settings,
      this.lastCompletionTime
    )) {
      console.log("\uC790\uB3D9\uC644\uC131 \uD2B8\uB9AC\uAC70 \uC870\uAC74 \uCDA9\uC871");
      this.editorHandler.recordEdit("insert", "", position.line * 1e3 + position.ch);
      await this.triggerCompletion(editor, activeView);
    } else {
      console.log("\uC790\uB3D9\uC644\uC131 \uD2B8\uB9AC\uAC70 \uC870\uAC74 \uBD88\uCDA9\uC871");
      this.editorHandler.recordEdit("insert", "", position.line * 1e3 + position.ch);
    }
  }
  onKeyDown(event) {
    const activeEditor = this.getActiveEditor();
    if (!activeEditor || !this.settings.enabled) {
      return;
    }
    if (this.ghostTextManager.hasGhostText()) {
      const handled = this.ghostTextManager.handleKeyNavigation(event.key, activeEditor);
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
    }
    if (event.key.length === 1 || event.key === "Backspace" || event.key === "Delete" || event.key === "Enter") {
      this.ghostTextManager.clearGhostText();
    }
  }
  async triggerCompletion(editor, view) {
    if (this.isProcessingCompletion) {
      return;
    }
    this.isProcessingCompletion = true;
    const cursor = editor.getCursor();
    try {
      this.ghostTextManager.showLoadingIndicator(editor, cursor);
      this.updateStatusBar("AI \uC644\uC131 \uC0DD\uC131 \uC911...");
      const context = this.editorHandler.analyzeContext(
        editor,
        view.file,
        this.settings
      );
      if (this.settings.language === "auto") {
        const detectedLanguage = this.editorHandler.detectLanguage(context.beforeCursor);
        this.settings.language = detectedLanguage === "mixed" ? "korean" : detectedLanguage;
      }
      if (this.settings.autoDetectContext) {
        const detectedContext = this.editorHandler.detectWritingContext(context);
        this.adjustSettingsForContext(detectedContext);
      }
      const request = {
        text: context.beforeCursor,
        cursorPosition: cursor.line * 1e3 + cursor.ch,
        fileName: context.fileName,
        fileType: context.fileType,
        tags: context.tags,
        context,
        settings: this.settings
      };
      const completion = await this.aiService.generateCompletion(request);
      this.lastCompletionTime = Date.now();
      await this.saveSettings();
      this.ghostTextManager.showGhostText(editor, completion, cursor);
      this.updateStatusBar(`AI \uC644\uC131 \uC900\uBE44\uB428 (${completion.model})`);
      if (this.settings.showDebugInfo) {
        console.log("AI Completion:", {
          request,
          response: completion,
          context
        });
      }
    } catch (error) {
      console.error("AI completion error:", error);
      this.ghostTextManager.clearGhostText();
      this.updateStatusBar("AI \uC644\uC131 \uC2E4\uD328");
      let errorMessage = "AI \uC644\uC131\uC744 \uC0DD\uC131\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.";
      if (error.message.includes("API key")) {
        errorMessage = "API \uD0A4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      } else if (error.message.includes("network") || error.message.includes("fetch")) {
        errorMessage = "\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      } else if (error.message.includes("Ollama")) {
        errorMessage = "Ollama \uC11C\uBC84\uAC00 \uC2E4\uD589 \uC911\uC778\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (this.settings.showDebugInfo) {
        new import_obsidian3.Notice(`${errorMessage}
\uB514\uBC84\uADF8: ${error.message}`);
      } else {
        new import_obsidian3.Notice(errorMessage);
      }
    } finally {
      this.isProcessingCompletion = false;
    }
  }
  adjustSettingsForContext(context) {
    switch (context) {
      case "academic":
        this.settings.writingStyle = "academic";
        this.settings.temperature = 0.3;
        break;
      case "creative":
        this.settings.writingStyle = "creative";
        this.settings.temperature = 0.8;
        break;
      case "technical":
        this.settings.writingStyle = "technical";
        this.settings.temperature = 0.4;
        break;
      case "list":
        this.settings.completionType = "bullet";
        break;
      default:
        break;
    }
  }
  getActiveEditor() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    return activeView ? activeView.editor : null;
  }
  addCommands() {
    this.addCommand({
      id: "toggle-ai-completion",
      name: "AI \uC644\uC131 \uCF1C\uAE30/\uB044\uAE30",
      callback: () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        if (this.settings.enabled) {
          this.enableCompletion();
          new import_obsidian3.Notice("AI \uC644\uC131\uC774 \uD65C\uC131\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        } else {
          this.disableCompletion();
          new import_obsidian3.Notice("AI \uC644\uC131\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        }
      }
    });
    this.addCommand({
      id: "trigger-ai-completion",
      name: "AI \uC644\uC131 \uC218\uB3D9 \uC2E4\uD589",
      editorCallback: async (editor, ctx) => {
        if (!this.settings.enabled) {
          new import_obsidian3.Notice("AI \uC644\uC131\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
          return;
        }
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (view) {
          await this.triggerCompletion(editor, view);
        }
      }
    });
    this.addCommand({
      id: "accept-ghost-text",
      name: "Ghost Text \uC218\uB77D",
      editorCallback: (editor) => {
        const text = this.ghostTextManager.acceptGhostText();
        if (text) {
          editor.replaceRange(text, editor.getCursor());
        }
      }
    });
    this.addCommand({
      id: "dismiss-ghost-text",
      name: "Ghost Text \uCDE8\uC18C",
      callback: () => {
        this.ghostTextManager.clearGhostText();
      }
    });
    this.addCommand({
      id: "clear-ai-cache",
      name: "AI \uCE90\uC2DC \uC0AD\uC81C",
      callback: () => {
        this.aiService.clearCache();
        new import_obsidian3.Notice("AI \uCE90\uC2DC\uAC00 \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      }
    });
  }
  setupStatusBar() {
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("AI \uC644\uC131 \uC900\uBE44\uB428");
  }
  updateStatusBar(text) {
    if (this.statusBarItem) {
      this.statusBarItem.setText(text);
    }
  }
  enableCompletion() {
    this.settings.enabled = true;
    this.updateStatusBar("AI \uC644\uC131 \uD65C\uC131\uD654");
    console.log("AI completion enabled");
  }
  disableCompletion() {
    this.settings.enabled = false;
    this.ghostTextManager.clearGhostText();
    this.editorHandler.clearDebounceTimer();
    this.updateStatusBar("AI \uC644\uC131 \uBE44\uD65C\uC131\uD654");
    console.log("AI completion disabled");
  }
  // Public method for settings tab
  getAIService() {
    return this.aiService;
  }
  // Debug methods
  async testCompletion() {
    const editor = this.getActiveEditor();
    if (!editor) {
      new import_obsidian3.Notice("\uD65C\uC131 \uD3B8\uC9D1\uAE30\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("\uB9C8\uD06C\uB2E4\uC6B4 \uBDF0\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    new import_obsidian3.Notice("AI \uC644\uC131 \uD14C\uC2A4\uD2B8\uB97C \uC2DC\uC791\uD569\uB2C8\uB2E4...");
    await this.triggerCompletion(editor, activeView);
  }
  getDebugInfo() {
    return {
      settings: this.settings,
      hasGhostText: this.ghostTextManager.hasGhostText(),
      lastCompletionTime: this.lastCompletionTime,
      isProcessing: this.isProcessingCompletion,
      cacheSize: this.aiService.getCacheSize(),
      providers: this.aiService.getProviders().map((p) => ({
        id: p.id,
        name: p.name,
        models: p.models.length
      }))
    };
  }
};
